# Отчет о реализации интеграции с API в проекте "Euro Lottery"

## Введение

В данном отчете представлены результаты работы по интеграции с бэкендом API в проекте "Euro Lottery". Реализация включает в себя создание надежной системы для работы с API, поддержку офлайн-режима, кэширование данных и другие важные компоненты, необходимые для создания отказоустойчивого приложения.

## 1. Кэширование данных с использованием IndexedDB

### Основные возможности:

- **Двухуровневая система кэширования**: `cacheService` реализует кэширование как в памяти (для быстрого доступа), так и в IndexedDB (для постоянного хранения между сеансами).
- **Умная стратегия хранения**: Каждый тип данных имеет собственное время жизни в кэше, основанное на его природе и частоте обновления:
  ```javascript
  const cacheTTLs = {
    'default': DEFAULT_CACHE_TTL, // 1 час
    'lottery/games': 12 * 60 * 60 * 1000, // 12 часов для списка лотерей
    'lottery/draws/past': 24 * 60 * 60 * 1000, // 24 часа для прошедших розыгрышей
    'stats': 6 * 60 * 60 * 1000, // 6 часов для статистики
    // ...другие настройки
  };
  ```
- **Автоматическая валидация**: Система автоматически проверяет и удаляет устаревшие записи кэша.
- **Метрики кэширования**: Реализована возможность получения статистики кэша, включая количество записей, размер и другую аналитику.

### Практическое применение:

Каждый API запрос проходит через интерцептор, который проверяет наличие данных в кэше:

```javascript
// Проверяем наличие в кэше
const endpoint = config.url.replace(API_URL, '');
const cachedData = await cacheService.getCache(endpoint, config.params);

if (cachedData) {
  // Данные есть в кэше, прерываем HTTP запрос и возвращаем кэшированные данные
  // ...
}
```

## 2. Поддержка оффлайн-режима и синхронизация

### Основные возможности:

- **Обнаружение состояния сети**: `networkService` отслеживает изменения сетевого состояния и уведомляет пользователя.
- **Очередь оффлайн-операций**: Когда пользователь находится офлайн, мутирующие запросы (POST, PUT, DELETE) добавляются в очередь для последующего выполнения:
  ```javascript
  if (!navigator.onLine && config.method !== 'get') {
    // Добавляем в очередь оффлайн-операций
    await cacheService.addOfflineOperation(
      endpoint,
      config.method.toUpperCase(),
      config.data
    );
    // ...
  }
  ```
- **Автоматическая синхронизация**: При восстановлении подключения, система автоматически выполняет отложенные операции:
  ```javascript
  handleOnline() {
    // ...
    this.checkRealConnectivity().then(isReallyOnline => {
      if (isReallyOnline) {
        // Попытка синхронизации оффлайн-операций
        this.syncOfflineOperations();
      }
    });
  }
  ```
- **Интеллектуальная проверка соединения**: Дополнительная проверка реального подключения к серверу, а не только флага `navigator.onLine`.
- **Уведомления о синхронизации**: Пользователь получает уведомления о состоянии синхронизации.

### Инвалидация кэша при синхронизации:

После успешного выполнения отложенной операции, система автоматически инвалидирует связанные кэши:

```javascript
if (['POST', 'PUT', 'PATCH', 'DELETE'].includes(operation.method)) {
  // Определяем какие разделы кэша нужно очистить
  const cachePatternsToInvalidate = this.getCachePatternsForEndpoint(operation.endpoint);
  
  for (const pattern of cachePatternsToInvalidate) {
    await cacheService.clearCache(pattern);
  }
}
```

## 3. Универсальная обработка ошибок

### Основные возможности:

- **Умная классификация ошибок**: Система анализирует различные типы ошибок и предоставляет понятные сообщения пользователю:
  ```javascript
  // Оффлайн ошибка
  if (error.isOffline || (error.message && (
      error.message.includes('network') || 
      error.message.includes('connection')
  ))) {
    return {
      message: 'Нет подключения к интернету. Проверьте подключение и повторите попытку.',
      isOffline: true
    };
  }
  ```
- **Автоматическое восстановление после ошибок**:
  - Автоматическое обновление токена доступа
  - Повторные попытки при временных проблемах
  - Вывод кэшированных данных при отсутствии соединения
- **Обработка ошибок валидации форм**: Преобразование серверных ошибок валидации в формат, удобный для отображения в формах.
- **Централизованная логика обработки**: Весь код обработки ошибок находится в одном месте (`useApi` хук).

### Функция анализа ошибок:

```javascript
const getErrorMessage = (error) => {
  // Обработка различных типов ошибок
  // ...
  
  // Стандартные сообщения по HTTP статусам
  switch (status) {
    case 400:
      return { message: 'Неверный запрос. Пожалуйста, проверьте данные.', status };
    case 401:
      return { message: 'Требуется авторизация. Пожалуйста, войдите в систему.', status };
    // ...другие статусы
  }
  
  // ...
};
```

## 4. Индикаторы загрузки

### Основные возможности:

- **Многоуровневая система индикаторов**:
  - Глобальный индикатор для тяжелых операций
  - Минимальный индикатор для фоновых запросов
  - Локальные индикаторы для конкретных компонентов
- **Интеллектуальное управление состоянием**: Система автоматически контролирует отображение индикаторов в зависимости от количества активных запросов.
- **Настраиваемые тексты загрузки**: Возможность указать специфичный текст для каждого запроса.
- **Автоматическая интеграция с API**: Система индикации автоматически реагирует на изменение счетчика запросов.

### Компоненты загрузки:

1. **Глобальный индикатор** - полноэкранный оверлей для блокирующих операций:
   ```javascript
   <GlobalLoadingOverlay />
   ```

2. **Минимальный индикатор** - ненавязчивое уведомление о фоновой загрузке:
   ```javascript
   <MinimalLoadingIndicator position="top-right" />
   ```

3. **Индикатор в конкретном месте** - для показа загрузки внутри компонента:
   ```javascript
   <LoadingPlaceholder height="200px" text="Загрузка лотерей..." isLoading={isLoading} />
   ```

## 5. Улучшенный API-сервис с организацией по доменам

### Основные возможности:

- **Группировка по доменам**: API-функции организованы по бизнес-доменам, что упрощает навигацию и поддержку кода:
  ```javascript
  const apiService = {
    auth: {
      login: (credentials) => api.post('/users/login/', credentials),
      register: (userData) => api.post('/users/register/', userData),
      // ...
    },
    lottery: {
      getLotteries: (params, options = {}) => api.get('/lottery/games/', {
        params,
        ...createCacheOptions(6 * 60 * 60 * 1000, options.forceRefresh)
      }),
      // ...
    },
    payment: {
      // ...
    },
    // ...другие домены
  };
  ```
- **Декларативная настройка кэширования**: Каждый метод API имеет собственные настройки кэширования, соответствующие его характеристикам:
  ```javascript
  // Предстоящие тиражи с коротким кэшированием (часто обновляются)
  getUpcomingDraws: (params, options = {}) => api.get('/lottery/draws/upcoming/', {
    params,
    ...createCacheOptions(5 * 60 * 1000, options.forceRefresh) // 5 минут кэш
  }),
  
  // Прошедшие тиражи с долгим кэшированием
  getPastDraws: (params, options = {}) => api.get('/lottery/draws/past/', {
    params,
    ...createCacheOptions(12 * 60 * 60 * 1000, options.forceRefresh) // 12 часов кэш
  }),
  ```
- **Встроенные перехватчики запросов и ответов**:
  - Автоматическое добавление токенов авторизации
  - Обработка истечения срока действия токена
  - Кэширование GET-запросов
  - Обработка оффлайн-режима

## Примеры использования API-сервиса

### 1. Базовый запрос с использованием хука useApi:

```javascript
import { useApi } from '../hooks';
import apiService from '../services/api';

function ProfileComponent() {
  const api = useApi();
  const [profile, setProfile] = useState(null);
  
  const loadProfile = async () => {
    try {
      await api.execute(
        () => apiService.user.getProfile(),
        {
          onSuccess: (data) => {
            setProfile(data);
          }
        }
      );
    } catch (error) {
      console.error('Ошибка загрузки профиля:', error);
    }
  };
  
  // ...
}
```

### 2. Запрос с принудительным обновлением данных:

```javascript
// Обновление списка лотерей, игнорируя кэш
api.execute(
  () => apiService.lottery.getLotteries({}, { forceRefresh: true }),
  {
    onSuccess: (data) => {
      setLotteries(data.results);
    }
  }
);
```

### 3. Обработка оффлайн-режима:

```javascript
// Покупка билета с возможностью оффлайн-обработки
api.execute(
  () => apiService.lottery.purchaseTicket(ticketData),
  {
    onSuccess: (data, meta) => {
      if (meta.queued) {
        // Показываем уведомление о постановке в очередь
        showNotification('Билет будет куплен, когда будет восстановлено подключение');
      } else {
        // Нормальная обработка успешной покупки
        navigateToTicketDetails(data.ticket_id);
      }
    }
  }
);
```

## Заключение

Реализованная интеграция с API обеспечивает:

- **Высокую производительность** благодаря кэшированию данных
- **Отказоустойчивость** при проблемах с сетью
- **Улучшенный пользовательский опыт** с информативными индикаторами загрузки
- **Понятные сообщения об ошибках** в различных ситуациях
- **Структурированный и поддерживаемый код** API-сервиса

Эта реализация значительно улучшает работу приложения в различных сетевых условиях и создает отказоустойчивую основу для дальнейшего развития проекта.

---

**Ключевые результаты:**

✅ Снижение нагрузки на сервер благодаря интеллектуальному кэшированию  
✅ Поддержка работы приложения без подключения к интернету  
✅ Автоматическая синхронизация данных при восстановлении соединения  
✅ Понятные сообщения об ошибках для пользователей  
✅ Удобная организация API-вызовов по функциональным доменам